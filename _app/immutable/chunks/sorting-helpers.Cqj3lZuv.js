import{a as B,t as W}from"./index.DkFET82d.js";import{r as j}from"./scheduler.oylLmlEu.js";import{w as y}from"./paths.DscfQXoR.js";function J(e){return(e==null?void 0:e.length)!==void 0?e:Array.from(e)}function V(e,t){e.d(1),t.delete(e.key)}function X(e,t){W(e,1,1,()=>{t.delete(e.key)})}function Z(e,t,s,n,r,u,S,d,T,I,b,U){let f=e.length,w=u.length,l=f;const R={};for(;l--;)R[e[l].key]=l;const p=[],P=new Map,v=new Map,O=[];for(l=w;l--;){const a=U(r,u,l),c=s(a);let i=S.get(c);i?n&&O.push(()=>i.p(a,t)):(i=I(c,a),i.c()),P.set(c,p[l]=i),c in R&&v.set(c,Math.abs(l-R[c]))}const M=new Set,g=new Set;function A(a){B(a,1),a.m(d,b),S.set(a.key,a),b=a.first,w--}for(;f&&w;){const a=p[w-1],c=e[f-1],i=a.key,h=c.key;a===c?(b=a.first,f--,w--):P.has(h)?!S.has(i)||M.has(i)?A(a):g.has(h)?f--:v.get(i)>v.get(h)?(g.add(i),A(a)):(M.add(h),f--):(T(c,S),f--)}for(;f--;){const a=e[f];P.has(a.key)||T(a,S)}for(;w;)A(p[w-1]);return j(O),p}var N=(e=>(e.BUBBLE_SORT="bubbleSort",e.QUICK_SORT="quickSort",e.SELECTION_SORT="selectionSort",e.INSERTION_SORT="insertionSort",e))(N||{}),o=(e=>(e.STARTED="started",e.STOPPED="stopped",e.RESET="reset",e.EMPTY_STATUS="emptyStatus",e))(o||{}),E=(e=>(e.COMPARE="compare",e.SWAP="swap",e.AFTER_SORTING="afterSorting",e))(E||{});const _=Object.values(N);let k=500;function $(e){k=e}function F(){return k}function G(){const{subscribe:e,update:t}=y(new Map(_.map(s=>[s,!0])));return{subscribe:e,toggleAlgorithm:s=>{t(n=>(n.set(s,!n.get(s)),n))},toggleAll:()=>t(s=>{const n=[...s.values()].every(r=>!!r);return[...s.keys()].forEach(r=>s.set(r,!n)),s})}}function L(){const{subscribe:e,set:t}=y(o.STOPPED);return{set:t,updateStatus:s=>{let n;switch(s){case o.STARTED:n=o.STOPPED;break;case o.STOPPED:n=o.STARTED;break;case o.RESET:n=o.STARTED;case o.EMPTY_STATUS:n=o.STARTED}t(n)},subscribe:e}}function Y(){const{subscribe:e,set:t}=y(D());return{subscribe:e,generate:()=>t(D())}}function q(){const{subscribe:e,update:t}=y(new Map(_.map((s,n)=>[s,{history:[],sortedNumbers:0}])));return{subscribe:e,updateRanking:(s,n)=>{t(r=>{const u=r.get(s);u&&r.set(s,{...u,sortedNumbers:n});const S=new Map;return[...r.entries()].sort((d,T)=>T[1].sortedNumbers-d[1].sortedNumbers).map(d=>d[0]).map(d=>{const T=r.get(d);T&&S.set(d,T)}),S})},updateHistory:(s,n)=>t(r=>{const u=r.get(s);return u&&r.set(s,{...u,history:[...u.history,{...n}]}),r})}}const x=G(),ee=L(),te=Y(),se=q();function D(){return[...Array(12).keys()].map(()=>Math.round(Math.random()*9+1))}let m,H=()=>{};function ne(){m=new Promise(e=>{H=e})}async function*ae(e,t){yield{type:E.COMPARE,prevIndex:e,curIndex:t},await C(F()),await m}async function*re(e,t,s){await m;const n=e[t];e[t]=e[s],e[s]=n,yield{type:E.SWAP,prevIndex:t,curIndex:s,array:e},await C(200),await m}async function*ce(e,t=!0){yield{type:E.AFTER_SORTING,curIndex:e,isRange:t}}function C(e){return new Promise(t=>setTimeout(t,e))}export{o as S,ne as a,ee as b,re as c,V as d,J as e,ce as f,E as g,_ as h,X as i,x as j,$ as k,te as n,ae as o,H as r,se as s,Z as u};
